import math
import threading
import time

#returns number n or below with longest collatz sequence
def longestCollatz(n):
    answers = {1:1}
    longest = 1
    for i in range(2,n+1):
        if i in answers.keys():
            continue
        temp = i
        tempLength = 0
        while temp not in answers.keys():
            if temp%2 == 0:
                temp = temp/2
            else:
                temp = 3*temp + 1
            tempLength += 1
        answers[i] = tempLength + answers[temp]
        if answers[i] > answers[longest]:
            longest = i

    return longest
    

def sum35(n):
    total = 0
    for i in range(1, n):
        if i%3 == 0 or i%5 == 0:
            total += i

    return total


'''Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
appended fibonaccis to solutions list and added the even ones until last fibonacci is over limit. Anser is 4613732'''

def dynamicFibonacciEvenSum(limit, fibonaccis = [0,1]):
    total = 0
    while fibonaccis[-1] < limit:
        fibonaccis.append(fibonaccis[-2] + fibonaccis[-1])
        if not fibonaccis[-1] % 2 and fibonaccis[-1] < limit:
            total += fibonaccis[-1]

    return total


# Brute force for 3. greatest prime under a number. could be optimized but got it
def primesUnder(n):
    primes = []
    for i in range(2, n):
        isPrime = True
        for prime in primes:
            if i % prime == 0:
                isPrime = False
                break
        if isPrime:
            primes.append(i)

    return primes

def greatestPrimeFactor(n):
    primes = primesUnder(math.floor(math.sqrt(n)))
    i = -1
    while n % primes[i] != 0:
        i -= 1
    return primes[i]

print(greatestPrimeFactor(600851475143))

    
    
    

        